= API UDP socket client

== DEFINES
=== Timeout for UDP requests
==== Function:
 Default timeout for UDP requests when waiting for a response

==== Note:
[NOTE]
Fixed value. To change ELClientUdp.h must be changed

==== Prototype:
[source, c]
#define DEFAULT_UDP_TIMEOUT  5000

==== Parameters:
==== Defaults:
 5000ms

==== Return:
==== Example:
___
___
=== Callback type
==== Function:
 Type of callback from ELClient. Value USERCB_SENT indicates an UDP packet has been sent, USERCB_RECV indicates an UDP packet has been received

==== Note:
[NOTE]
Fixed value.

==== Prototype:
[source, c]
 #define USERCB_SENT 0
 #define USERCB_RECV 1

==== Parameters:
==== Defaults:
==== Return:
==== Example:
[source, c++]
void udpCb(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data)
{
  Serial.println("udpCb is called");
  if (len > 0)  // sending complete (no confirmation that it was received!) or we received something
  {
    if (resp_type == USERCB_SENT)
    {
      Serial.println("\tSent " + String(len) + " bytes over connection #" + String(client_num));
    }
    else if (resp_type == USERCB_RECV)
    {
      char recvData[len+1]; // Prepare buffer for the received data
      memcpy(recvData, data, len); // Copy received data into the buffer
      recvData[len] = '\0'; // Terminate the buffer with 0 for proper printout!
      Serial.println("\tReceived " + String(len) + " bytes over client#" + String(client_num));
      Serial.println("\tReceived: " + String(recvData));
    }
    else
    {
      Serial.println("Received invalid response type");
    }
  }
  else if (len < 0) // negative result means there was a problem
  {
    Serial.print("Send error: ");
    Serial.println(getErrTxt(len));
  }
}

== FUNCTIONS
=== class ELClientUdp
==== Function:
The ELClientUdp class sends data over a simple UDP socket to a remote server. Each instance is used to communicate with one server and multiple instances can be created to send to multiple servers.
The ELClientUdp class does not support concurrent requests to the same server because only a single response can be recevied at a time and the responses of the two requests may arrive out of order.

==== Note:

==== Prototype:
[source, c]
ELClientUdp(ELClient *e);

==== Parameters:
 ELClient *e:: Pointer to ELClient. Check ELClient API documentation.

==== Defaults:

==== Return:

==== Example:
[source, c++]
ELClientUdp udp(&esp);

___
___
=== begin
==== Function:
 Initialize communication to a remote server, this communicates with esp-link but does not open a connection to the remote server.

==== Note:
[CAUTION]
Port MUST NOT be 80, 23 or 2323, as these ports are already used by EL-CLIENT on the ESP8266.

[WARNING]
Max 4 connections are supported!

==== Prototype:
[source, c]
int begin(const char* host, uint16_t port, void (*userCb)(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data)=0);

==== Parameters:
 const char* host:: Host to be connected. Can be a URL or an IP address in the format of xxx.xxx.xxx.xxx . To make a UDP broadcast (send UDP packet to more than one IP) use the host argument as the netmask. Ex.: "192.168.0.255" sends to UDP packet to all IPs from 192.168.0.0 to 192.168.0.254
 uint16_t port:: Port to be used to send/receive packets. Port MUST NOT be 80, 23 or 2323, as these ports are already used by EL-CLIENT on the ESP8266
 void (*userCb)(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data):: Pointer to callback function that is called if data after data has been sent, received or if an error occured

==== Defaults:
 void (*userCb)(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data):: Defaults to NULL if not set in the Function

==== Return:
 int <result>:: 0 if successfull or negative error code

Error codes:

 -1 Wrong number of arguments (should never happen)
 -2 hostname longer than 128 characters
 -3 out of memory (ESP8266)
 -4 invalid hostname
 -5 invalid port number
 -6 other internal error (ESP8266)

==== Example:
[source, c++]
int err = udp.begin(udpServer, udpPort, udpCb);
if (err != 0)
{
  Serial.print("UDP begin failed: ");
  Serial.println(err);
}
else
{
  Serial.print("UDP setup successful");
}

___
___
=== send
==== Function:
 Send data to the remote server. The data must be null-terminated or the length must be specified.

==== Note:

==== Prototype:
[source, c]
 void send(const char* data);
 void send(const char* data, int len);

==== Parameters:
 const char* data:: Pointer to UDP packet, if parameter len is missing this must be null-terminated
 int len:: Length of UDP packet (no need to null-terminate)

==== Defaults:

==== Return:

==== Example:
[source, c]
Serial.println("Sending text message to UDP server");
udp.send("Message from your Arduino Uno WiFi over UDP socket");
Serial.println("Sending JSON array to UDP server");
char udpPacket = "{"device":"spm","s":622.02,"c":-165.86}"
udp.send(udpPacket, 39);

___
___
=== getResponse
==== Function:
Retrieve the response from the remote server, returns the number of send or received bytes, 0 if no response (may need to wait longer)

==== Note:
[CAUTION]
!!! UDP doesn't check if the data was received or if the receiver IP/socket is available !!!

[WARNING]
Received packet is NOT null-terminated

==== Prototype:
[source, c++]
uint16_t getResponse(uint8_t *resp_type, uint8_t *client_num, char* data, uint16_t maxLen);

==== Parameters:
 uint8_t *resp_type:: Pointer to response type. Is USERCB_SENT if packet was sent or USERCB_RECV if a packet was received.
 uint8_t *client_num:: Pointer to connection number. Can be used to distinguish between different UDP clients.
 char* data:: Pointer to buffer for received packet
 uint16_t maxLen:: Size of buffer for received packet. If the received packet is larger than the buffer, the received packet will be truncated.

==== Defaults:

==== Return:
 uint16_t <len>:: Size of received packet or number of sent bytes or 0 if no response

==== Example:
[source, c++]
#define BUFLEN 266
void loop() {
  // process any callbacks coming from esp_link
  esp.Process();
  // Check if we received a packet or if the last send request has finished
  char response[BUFLEN];
  memset(response, 0, BUFLEN);
  uint8_t resp_type;
  uint8_t client_num;
  uint16_t len = udp.getResponse(&resp_type, &client_num, response, BUFLEN);
  if (len != 0)
  {
    if (resp_type == USERCB_SENT)
    {
      Serial.println("Sent "+String(len)+" bytes");
    }
    else
    {
      Serial.print("Received packet: ");
      for (int i=0; i<len; i++)
      {
        Serial.print(response[i]);
      }
      Serial.println("");
    }
  }
}

___
___
=== waitResponse
==== Function:
Wait for the response from the remote server, returns the number of send or received bytes, 0 if no response (may need to wait longer)

==== Note:
[CAUTION]
**Blocks the Arduino code for 5 seconds! not recommended to use.**

[TIP]
Use callback function instead!

[CAUTION]
 !!! UDP doesn't check if the data was received or if the receiver IP/socket is available !!!

[WARNING]
Received packet is NOT null-terminated

==== Prototype:
 uint16_t waitResponse(uint8_t *resp_type, uint8_t *client_num, char* data, uint16_t maxLen, uint32_t timeout=DEFAULT_UDP_TIMEOUT);

==== Parameters:
 uint8_t *resp_type:: Pointer to response type. Is USERCB_SENT if packet was sent or USERCB_RECV if a packet was received.
 uint8_t *client_num:: Pointer to connection number. Can be used to distinguish between different UDP clients.
 char* data:: Pointer to buffer for received packet
 uint16_t maxLen:: Size of buffer for received packet. If the received packet is larger than the buffer, the received packet will be truncated.

==== Defaults:
uint32_t timeout:: Is the default timeout of 5 seconds if not set

==== Return:
 uint16_t <len>:: Size of received packet or number of sent bytes or 0 if no response

==== Example:
[source, c++]
#define BUFLEN 266
bool haveRemoteResponse = true;
void loop() {
  // process any callbacks coming from esp_link
  esp.Process();
  if (haveRemoteResponse) { // If last packet was sent, send a new one
    Serial.println("Sending JSON array to UDP server");
    char udpPacket = "{"device":"spm","s":622.02,"c":-165.86}"
    udp.send(udpPacket, 39);
    haveRemoteResponse = false;
  }
  // Check if we received a packet or if the last send request has finished
  char response[BUFLEN];
  memset(response, 0, BUFLEN);
  uint8_t resp_type;
  uint8_t client_num;
  uint16_t len = udp.waitResponse(&resp_type, &client_num, response, BUFLEN);
  if (len != 0)
  {
    if (resp_type == USERCB_SENT)
    {
      Serial.println("Sent "+String(len)+" bytes");
    }
    else
    {
      Serial.print("Received packet: ");
      for (int i=0; i<len; i++)
      {
        Serial.print(response[i]);
      }
      Serial.println("");
      haveRemoteResponse = true;
    }
  }
}

___
___
=== userCb
==== Function:
This function is called by ELClient library when a packet was sent, a packet was received or an error occured

==== Note:
[TIP]
The function is user specific and therefor included in the program code, not in the library

[TIP]
This function does not block the Arduino code execution


==== Prototype:
[source, c++]
void udpCb(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data);

==== Parameters:
 uint8_t resp_type:: Response type. Is USERCB_SENT if packet was sent or USERCB_RECV if a packet was received.
 uint8_t client_num:: Connection number. Can be used to distinguish between different UDP clients.
 uint16_t len:: Size of received packet.
 char* data:: Buffer with the received packet

==== Defaults:

==== Return:

==== Example:
[source, c++]
/**
 * Simple example to demo the El-Client UDP calls
 */
#include <ELClient.h>
#include <ELClientUdp.h>
// IP address for this demo is a local IP.
// Replace it with the IP address where you have a UDP socket server running
char * const udpServer PROGMEM = "192.168.0.101"; // Send to single ip address
// Port for this demo is the port used by the UDP socket server.
// Replace it with the port that your UDP socket server is listening to
uint16_t const udpPort PROGMEM = 5000;
// Initialize a connection to esp-link using the normal hardware serial port both for
// SLIP and for debug messages.
ELClient esp(&Serial);
// Initialize a UDP client on the connection to esp-link
ELClientUdp udp(&esp);
// Timer value to send out data
uint32_t wait;
// Time to wait between sending out data
uint32_t waitTime;
// Flag for wifi connection
boolean wifiConnected = false;
// Callback for UDP socket, called if data was sent or received
void udpCb(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data)
{
  Serial.println("udpCb is called");
  if (len > 0) // sending complete or we received something
  {
    if (resp_type == USERCB_SENT)
    {
      Serial.println("\tSent " + String(len) + " bytes over connection #" + String(client_num));
    }
    else if (resp_type == USERCB_RECV)
    {
      char recvData[len+1]; // Prepare buffer for the received data
      memcpy(recvData, data, len); // Copy received data into the buffer
      recvData[len] = '\0'; // Terminate the buffer with 0 for proper printout!
      Serial.println("\tReceived " + String(len) + " bytes over client#" + String(client_num));
      Serial.println("\tReceived: " + String(recvData));
    }
  }
  else if (len < 0) // negative result means there was a problem
  {
    Serial.println("UDP error: "*String(len);
  }
}
// Callback made from esp-link to notify of wifi status changes
// Here we print something out and set a global flag
void wifiCb(void *response)
{
  ELClientResponse *res = (ELClientResponse*)response;
  if (res->argc() == 1)
  {
    uint8_t status;
    res->popArg(&status, 1);
    if(status == STATION_GOT_IP)
    {
      Serial.println("WIFI CONNECTED");
      wifiConnected = true;
    }
    else
    {
      Serial.print("WIFI NOT READY: ");
      Serial.println(status);
      wifiConnected = false;
    }
  }
}
void setup()
{
  Serial.begin(9600);
  Serial.println("EL-Client starting!");
  // Sync-up with esp-link, this is required at the start of any sketch and initializes the
  // callbacks to the wifi status change callback. The callback gets called with the initial
  // status right after Sync() below completes.
  esp.wifiCb.attach(wifiCb); // wifi status change callback, optional (delete if not desired)
  bool ok;
  do
  {
    ok = esp.Sync(); // sync up with esp-link, blocks for up to 2 seconds
    if (!ok) Serial.println(F("EL-Client sync failed!"));
  } while(!ok);
  Serial.println(F("EL-Client synced!"));
  // Get immediate wifi status info for demo purposes. This is not normally used because the
  // wifi status callback registered above gets called immediately.
  esp.GetWifiStatus();
  ELClientPacket *packet;
  if ((packet=esp.WaitReturn()) != NULL)
  {
    Serial.print(F("Wifi status: "));
    Serial.println(packet->value);
  }
  // Set up the UDP socket client to send a short message to <udpServer> on port <>, this doesn't connect to that server,
  // it just sets-up stuff on the esp-link side
  int err = udp.begin(udpServer, udpPort, udpCb);
  if (err != 0)
  {
    Serial.print(F("UDP begin failed: "));
    Serial.println(err);
    delay(10000);
    asm volatile ("  jmp 0");
  }
  Serial.println(F("EL-Client ready!"));
  wait = millis()+29000; // Start first sending in 1 second
}
void loop() {
  // process any callbacks coming from esp_link
  esp.Process();
  // if we're connected send data over UDP socket
  if(wifiConnected)
  {
    if (millis() - wait > 30000) // Send some data every 30 seconds
    {
      wait = millis();
      // Send message to the previously set-up server #1
      Serial.print(F("Sending message to "));
      Serial.println(udpServer);
      udp.send("Message from your Arduino Uno WiFi over UDP socket");
    }
  }
}

___
___
