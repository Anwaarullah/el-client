ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
= API TCP socket client

anchor:bookmark-b[]

== DEFINES
=== Timeout for TCP requests
==== Function:
 Default timeout for TCP requests when waiting for a response

==== Note:
[NOTE]
Fixed value. To change ELClientTcp.h must be changed

==== Prototype:
[source, c]
#define DEFAULT_TCP_TIMEOUT  5000

==== Parameters:
==== Defaults:
 5000ms

==== Return:
==== Example:

___
___
=== Callback type
==== Function:
 Type of callback from ELClient. Value USERCB_SENT indicates an TCP packet has been sent, USERCB_RECV indicates an TCP packet has been received, USERCB_RECO indicates a connection problem, USERCB_CONN indicates the connection or disconnection of a client

==== Note:
[NOTE]
Fixed value.

==== Prototype:
[source, c]
 #define USERCB_SENT 0
 #define USERCB_RECV 1
 #define USERCB_RECO 2
 #define USERCB_CONN 3

==== Parameters:
==== Defaults:
==== Return:
==== Example:
[source, c++]
void tcpCb(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data)
{
	Serial.println("tcpCb connection #"+String(client_num));
	if (resp_type == USERCB_SENT)
  {
		Serial.println("\tSent " + String(len) + " bytes over client#" + String(client_num));
	}
  else if (resp_type == USERCB_RECV)
  {
		char recvData[len+1]; // Prepare buffer for the received data
		memcpy(recvData, data, len); // Copy received data into the buffer
		recvData[len] = '\0'; // Terminate the buffer with 0 for proper printout!
		Serial.println("\tReceived " + String(len) + " bytes over the server on connection #" + String(client_num));
		Serial.println("\tReceived: " + String(recvData));
		// TODO add some functions to react to the received data
		char *respHdr = "Received";
		tcp.send(respHdr,10);
	} else if (resp_type == USERCB_RECO) {
    Serial.println("\tConnection problem: "+String(len));
		}
	} else if (resp_type == USERCB_CONN) {
		if (len == 0) {
			Serial.println("\tDisconnected");
		} else {
			Serial.println("\tConnected");
		}
	} else {
		Serial.println("Received invalid response type");
	}
}

___
___
=== Socket mode
==== Function:
 Type of socket mode for TCP socket.
 Use SOCKET_CLIENT to setup a TCP client to send data without waiting for a response from the remote server
 Use SOCKET_CLIENT_LISTEN to setup a TCP client to send data and waiting for a response from the remote server
 Use SOCKET_SERVER to setup a TCP server and wait for a client to connect

==== Note:
[NOTE]
Fixed value.

==== Prototype:
[source, c]
#define SOCKET_CLIENT 0
#define SOCKET_CLIENT_LISTEN 1
#define SOCKET_SERVER 2

==== Parameters:
==== Defaults:
==== Return:
==== Example:
[source, c++]
/* Setup a simple client to send data and disconnect after data was sent */
tcpConnNum = tcp.begin(tcpServer, tcpPort, SOCKET_CLIENT, tcpCb);

[source, c++]
/* Setup a client to send data and wait for response from remote server */
tcpConnNum = tcp.begin(tcpServer, tcpPort, SOCKET_CLIENT_LISTEN, tcpCb);

[source, c++]
/* Setup a TCP server and wait for a client to connect */
tcpConnNum = tcp.begin(tcpServer, tcpPort, SOCKET_SERVER, tcpCb);

== FUNCTIONS
=== class ELClientTcp
==== Function:
 The ELClientTcp class sends data over a simple TCP socket to a remote server. Each instance is used to communicate with one server and multiple instances can be created to send to multiple servers.
 The ELClientTcp class does not support concurrent requests to the same server because only a single response can be recevied at a time and the responses of the two requests may arrive out of order.

==== Note:

==== Prototype:
[source, c]
ELClientTcp(ELClient *e);

==== Parameters:
 ELClient *e:: Pointer to ELClient. Check ELClient API documentation.

==== Defaults:

==== Return:

==== Example:
[source, c++]
ELClientTcp tcp(&esp);

___
___
=== begin
==== Function:
 Initialize communication to a remote server, this communicates with esp-link but does not open a connection to the remote server. Host may be a hostname or an IP address.
 Initialize a TCP socket server and wait for connecting clients.

==== Note:
[CAUTION]
Port MUST NOT be 80, 23 or 2323, as these ports are already used by EL-CLIENT on the ESP8266.

[WARNING]
Max 4 connections are supported!

==== Prototype:
[source, c]
int begin(const char* host, uint16_t port, uint8_t sock_mode, void (*userCb)(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data)=0);

==== Parameters:
 const char* host:: Host to be connected. Can be a URL or an IP address in the format of xxx.xxx.xxx.xxx .
 uint16_t port:: Port to be used to send/receive packets. Port MUST NOT be 80, 23 or 2323, as these ports are already used by EL-CLIENT on the ESP8266
 uint8_t sock_mode:: Select mode for this connection, simple client, client or server
 void (*userCb)(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data):: Pointer to callback function that is called if data after data has been sent, received or if an error occured

==== Defaults:
 void (*userCb)(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data):: Defaults to NULL if not set in the Function

==== Return:
 int <result>:: Connection number (used to distinguish between different connection callbacks or negative error code

 Error codes:
 -1 Wrong number of arguments (should never happen)
 -2 hostname longer than 128 characters
 -3 out of memory (ESP8266)
 -4 invalid hostname
 -5 invalid port number
 -6 other internal error (ESP8266)

==== Example:
[source, c++]
/* Setup a simple client to send data and disconnect after data was sent */
tcpConnNum = tcp.begin(tcpServer, tcpPort, SOCKET_CLIENT, tcpCb);

[source, c++]
/* Setup a client to send data and wait for response from remote server */
tcpConnNum = tcp.begin(tcpServer, tcpPort, SOCKET_CLIENT_LISTEN, tcpCb);

[source, c++]
/* Setup a TCP server and wait for a client to connect */
tcpConnNum = tcp.begin(tcpServer, tcpPort, SOCKET_SERVER, tcpCb);

___
___
=== send
==== Function:
 Send data to the remote server or reply to a connected client. The data must be null-terminated or the length must be specified.

==== Note:

==== Prototype:
[source, c]
 void send(const char* data);
 void send(const char* data, int len);

==== Parameters:
 const char* data:: Pointer to TCP packet, if parameter len is missing this must be null-terminated
 int len:: Length of TCP packet (no need to null-terminate)

==== Defaults:

==== Return:

==== Example:
[source, c]
Serial.println("Sending text message to TCP server");
tcp.send("Message from your Arduino Uno WiFi over TCP socket");
Serial.println("Sending JSON array to TCP server");
char tcpPacket = "{"device":"spm","s":622.02,"c":-165.86}"
tcp.send(tcpPacket, 39);

___
___
=== getResponse
==== Function:
 Retrieve the response from the remote server, returns the number of send or received bytes, 0 if no response (may need to wait longer)

==== Note:
[WARNING]
Received packet is NOT null-terminated

==== Prototype:
[source, c++]
uint16_t getResponse(uint8_t *resp_type, uint8_t *client_num, char* data, uint16_t maxLen);

==== Parameters:
 uint8_t *resp_type:: Pointer to response type. Is USERCB_SENT if packet was sent or USERCB_RECV if a packet was received.
 uint8_t *client_num:: Pointer to connection number. Can be used to distinguish between different TCP clients.
 char* data:: Pointer to buffer for received packet
 uint16_t maxLen:: Size of buffer for received packet. If the received packet is larger than the buffer, the received packet will be truncated.

==== Defaults:

==== Return:
 uint16_t <len>:: Size of received packet or number of sent bytes or 0 if no response

==== Example:
[source, c++]
#define BUFLEN 266
void loop() {
  // process any callbacks coming from esp_link
  esp.Process();
  // Check if we received a packet or if the last send request has finished
  char response[BUFLEN];
  memset(response, 0, BUFLEN);
  uint8_t resp_type;
  uint8_t client_num;
  uint16_t len = tcp.getResponse(&resp_type, &client_num, response, BUFLEN);
  if (len != 0)
  {
   if (resp_type == USERCB_SENT)
   {
    Serial.println("Sent "+String(len)+" bytes");
   }
   else
   {
    Serial.print("Received packet: ");
    for (int i=0; i<len; i++)
    {
      Serial.print(response[i]);
    }
    Serial.println("");
   }
  }
}

___
___
=== waitResponse
==== Function:
 Wait for the response from the remote server, returns the number of send or received bytes, 0 if no response (may need to wait longer)

==== Note:
[CAUTION]
**Blocks the Arduino code for 5 seconds! not recommended to use.**

[TIP]
Use callback function instead!

[WARNING]
Received packet is NOT null-terminated

==== Prototype:
 uint16_t waitResponse(uint8_t *resp_type, uint8_t *client_num, char* data, uint16_t maxLen, uint32_t timeout=DEFAULT_TCP_TIMEOUT);

==== Parameters:
 uint8_t *resp_type:: Pointer to response type. Is USERCB_SENT if packet was sent or USERCB_RECV if a packet was received.
 uint8_t *client_num:: Pointer to connection number. Can be used to distinguish between different TCP clients.
 char* data:: Pointer to buffer for received packet
 uint16_t maxLen:: Size of buffer for received packet. If the received packet is larger than the buffer, the received packet will be truncated.
 uint32_t timeout:: Timout in milli seconds to wait for a response, defaults to 5000ms

==== Defaults:
uint32_t timeout:: Is the default timeout of 5 seconds if not set

==== Return:
 uint16_t <len>:: Size of received packet or number of sent bytes or 0 if no response

==== Example:
[source, c++]
#define BUFLEN 266
bool haveRemoteResponse = true;
void loop() {
  // process any callbacks coming from esp_link
  esp.Process();
  if (haveRemoteResponse) { // If last packet was sent, send a new one
   Serial.println("Sending JSON array to TCP server");
   char tcpPacket = "{"device":"spm","s":622.02,"c":-165.86}"
   tcp.send(tcpPacket, 39);
   haveRemoteResponse = false;
  }
  // Check if we received a packet or if the last send request has finished
  char response[BUFLEN];
  memset(response, 0, BUFLEN);
  uint8_t resp_type;
  uint8_t client_num;
  uint16_t len = tcp.waitResponse(&resp_type, &client_num, response, BUFLEN);
  if (len != 0)
  {
   if (resp_type == USERCB_SENT)
   {
    Serial.println("Sent "+String(len)+" bytes");
   }
   else
   {
    Serial.print("Received packet: ");
    for (int i=0; i<len; i++)
    {
      Serial.print(response[i]);
    }
    Serial.println("");
    haveRemoteResponse = true;
   }
  }
}

___
___
=== userCb
==== Function:
 This function is called by ELClient library when a packet was sent, a packet was received or an error occured

==== Note:
[TIP]
The function is user specific and therefor included in the program code, not in the library

[TIP]
This function does not block the Arduino code execution


==== Prototype:
[source, c++]
void tcpCb(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data);

==== Parameters:
 uint8_t resp_type:: Response type. Possible values are USERCB_SENT (data sent), USERCB_RECV (data received), USERCB_RECO (connection error) or USERCB_CONN (connected or disconnected).
 uint8_t client_num:: Connection number. Can be used to distinguish between different TCP clients.
 uint16_t len:: Size of received packet.
 char* data:: Buffer with the received packet

==== Defaults:

==== Return:

==== Example:
[source, c++]
/**
 * Simple example to demo the El-Client TCP server
 * This example starts a TCP socket server and waits
 * for clients to connect
 */
#include <ELClient.h>
#include <ELClientTcp.h>
// IP address for this demo is a local IP.
// Replace it with the IP address where you have a TCP socket server running
char * const tcpServer PROGMEM = "192.168.0.103";
// Port for this demo is the port used by the TCP socket server.
// Replace it with the port that your TCP socket server is listening to
uint16_t const tcpPort PROGMEM = 7002;
// Initialize a connection to esp-link using the normal hardware serial port both for
// SLIP and for debug messages.
//ELClient esp(&Serial, &Serial);
// Initialize a TCP socket client on the connection to esp-link
ELClientTcp tcp(&esp);
// Connection number for tcp
int tcpConnNum;
// Timer value to send out data
uint32_t wait;
// Time to wait between sending out data
uint32_t waitTime;
// Flag for wifi connection
boolean wifiConnected = false;
// Callback for TCP socket, called if data was sent or received
// Receives socket client number, can be reused for all initialized TCP socket connections
void tcpCb(uint8_t resp_type, uint8_t client_num, uint16_t len, char *data)
{
	Serial.println("tcpCb connection #"+String(client_num));
	if (resp_type == USERCB_SENT)
  {
		Serial.println("\tSent " + String(len) + " bytes over client#" + String(client_num));
	}
  else if (resp_type == USERCB_RECV)
  {
		char recvData[len+1]; // Prepare buffer for the received data
		memcpy(recvData, data, len); // Copy received data into the buffer
		recvData[len] = '\0'; // Terminate the buffer with 0 for proper printout!
		Serial.println("\tReceived " + String(len) + " bytes over the server on connection #" + String(client_num));
		Serial.println("\tReceived: " + String(recvData));
		char respData[len+11]; // Prepare buffer for the response data
		char *respHdr = "Received: ";
		memcpy (respData, respHdr, 10);
		memcpy(&respData[10], recvData, len); // Copy received data into the buffer
		respData[len+10] = '\0';
		Serial.println("\tSend response: " + String(respData));
		tcp.send(respData);
	}
  else if (resp_type == USERCB_RECO)
  {
    Serial.println("Connection problem: "+String(len));
	}
  else if (resp_type == USERCB_CONN)
  {
		if (len == 0)
    {
			Serial.println("\tDisconnected");
		}
    else
    {
			Serial.println("\tConnected");
		}
	}
  else
  {
		Serial.println("Received invalid response type");
	}
}
// Callback made from esp-link to notify of wifi status changes
// Here we print something out and set a global flag
void wifiCb(void *response) {
	ELClientResponse *res = (ELClientResponse*)response;
	if (res->argc() == 1) {
		uint8_t status;
		res->popArg(&status, 1);
		if(status == STATION_GOT_IP) {
			Serial.println(F("WIFI CONNECTED"));
			wifiConnected = true;
		} else {
			Serial.print(F("WIFI NOT READY: "));
			Serial.println(status);
			wifiConnected = false;
		}
	}
}
void setup()
{
	Serial.begin(9600);
	Serial.println(F("EL-Client starting!"));
	// Sync-up with esp-link, this is required at the start of any sketch and initializes the
	// callbacks to the wifi status change callback. The callback gets called with the initial
	// status right after Sync() below completes.
	esp.wifiCb.attach(wifiCb); // wifi status change callback, optional (delete if not desired)
	bool ok;
	do
  {
		ok = esp.Sync();			// sync up with esp-link, blocks for up to 2 seconds
		if (!ok) Serial.println(F("EL-Client sync failed!"));
	} while(!ok);
	Serial.println(F("EL-Client synced!"));
	// Wit for WiFi to be connected.
	esp.GetWifiStatus();
	ELClientPacket *packet;
	Serial.print(F("Waiting for WiFi "));
	if ((packet=esp.WaitReturn()) != NULL)
  {
		Serial.print(F("."));
		Serial.println(packet->value);
	}
	Serial.println("");
	// Set up the TCP socket server to wait for a client on port <>,
	// it just sets-up stuff on the esp-link side and waits until a client sends some data
	tcpConnNum = tcp.begin(tcpServer, tcpPort, SOCKET_SERVER, tcpCb); // SOCKET_SERVER ==> accept connections
	if (tcpConnNum < 0)
  {
		Serial.println(F("TCP socket setup failed, try again in 10 seconds after reboot"));
	}
  else
  {
		Serial.println(String(tcpServer)+":"+String(tcpPort)+" is served over connection number # = "+String(tcpConnNum));
	}
	Serial.println(F("EL-TCP ready"));
}
void loop() {
	// process any callbacks coming from esp_link
	esp.Process();
}

___
___
